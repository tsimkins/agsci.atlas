from zope.schema.interfaces import IVocabularyFactory
from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
from zope.component import getAdapters
from zope.interface import implements

from agsci.atlas.interfaces import IRegistrationFieldset
from agsci.atlas.utilities import ploneify

from ..adapters import EventDataAdapter
from ..event.group import IEventGroup

def tokenify(v):
    return ploneify(v).replace('-', '_')

class RegistrationField(object):

    attrs = {
            'type' : 'field',
            'token' : '',
            'title' : '',
            'is_require' : False,
            'options' : [],
            'is_visitor_option' : True,
    }

    def __init__(self, **kwargs):

        self.data = {}

        # Iterate through the default attrs, and if we override them, set the
        # value on the data dict.  If not, set the default.
        for (k,v) in self.attrs.iteritems():

            value = kwargs.get(k, v)

            self.data[k] = value

        # Add title/token to options
        for i in range(0, len(self.data['options'])):
            v = self.data['options'][i]

            # If we passed in a raw string, convert it to a dict with
            # title/token as keys.  This lets us override the autogenerated
            # token if we change the title.
            if isinstance(v, (str, unicode)):
                self.data['options'][i] = {
                    'title' : v,
                    'token' : tokenify(v)
                 }

        # Remove empty fields
        for k in ('options',):
            if not self.data[k]:
                del self.data[k]

        # Initialize sort_order with 0
        self.data['sort_order'] = 0

        # Set token: Explicit, type (if not 'field', normalized title)
        if not self.data['token']:
            if self.data['type'] in ('field', 'checkbox', 'drop_down', 'radio', 'multiple'):
                self.data['token'] = tokenify(self.data['title'])
            else:
                self.data['token'] = self.data['type']


class BaseRegistrationFields(object):

    label = "Base"
    sort_order = 9999
    required = True

    fields = []

    def __init__(self, context):
        self.context = context

    def getFieldType(self, field):
        return 'field'

    def getFields(self):
        if hasattr(self, 'fields'):
            return [self.getFieldData(x) for x in self.fields]

        return []

    def getFieldData(self, field=None):
        return dict(getattr(field, 'data', {}))

class BasicRegistrationFields(BaseRegistrationFields):

    label = "Basic"
    sort_order = 10

    @property
    def fields(self):
        return [
            RegistrationField(
                type='firstname',
                title='First Name',
            ),
            RegistrationField(
                type='lastname',
                title='Last Name',
            ),
            RegistrationField(
                type='email',
                title='Email',
            ),
            RegistrationField(
                type='primary_phone',
                title='Primary Phone',
            ),
            RegistrationField(
                type='primary_phone_type',
                title='Primary Phone Type',
                options=['Home', 'Work', 'Mobile'],
            ),
        ]

class BusinessRegistrationFields(BaseRegistrationFields):

    label = "Business"
    sort_order = 20
    required = False

    @property
    def fields(self):
        return [
            RegistrationField(
                title='Company Name',
            ),
            RegistrationField(
                title='Address Line 1',
            ),
            RegistrationField(
                title='Address Line 2',
            ),
            RegistrationField(
                title='City',
            ),
            RegistrationField(
                title='State',
            ),
            RegistrationField(
                title='ZIP Code',
            ),
        ]

class AccessibilityRegistrationFields(BaseRegistrationFields):

    label = "Accessibility"
    sort_order = 30

    @property
    def fields(self):
        return [
            RegistrationField(
                token="accessibility",
                title='Do you require assistance?',
                options=['Audio', 'Visual', 'Mobile'],
                type='checkbox',
            )
        ]


class RegistrationFieldsetsVocabulary(object):

    implements(IVocabularyFactory)

    # Returns a list of fieldsets sorted in order
    def getRegistrationFieldsets(self, context):

        fieldsets = [x for x in getAdapters((context,), IRegistrationFieldset)]

        fieldsets.sort(key=lambda x: x[1].sort_order)

        return fieldsets

    def getDefaults(self, context):
        return [x[0] for x in self.getRegistrationFieldsets(context) if x[1].required]

    def __call__(self, context):

        # Check the request to make sure this is not being triggered by an import
        try:
            request_url = context.REQUEST.getURL()
        except:
            # Can't get the URL, don't do anything
            pass
        else:
            # If the URL contains '++add++', context is actually the container.
            # Do a check to see if IEventGroup is provided by the parent.
            if '++add++' in request_url:
                if IEventGroup.providedBy(context):
                    return SimpleVocabulary([])

        # If this context has a parent that's an IEventGroup, return an empty
        # vocabulary
        if EventDataAdapter(context).getParentId():
            return SimpleVocabulary([])

        # Initialize items list
        items = []

        # Iterate through fieldsets, and append to items
        for (name, fieldset) in self.getRegistrationFieldsets(context):
            items.append(SimpleTerm(name, title=fieldset.label))

        # Return a SimpleVocabulary of these items
        return SimpleVocabulary(items)

RegistrationFieldsetsVocabularyFactory = RegistrationFieldsetsVocabulary()